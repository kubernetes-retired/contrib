/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

// A simple binary for merging PR that match a criteria
// Usage:
//   submit-queue -token=<github-access-token> -user-whitelist=<file> --jenkins-host=http://some.host [-min-pr-number=<number>] [-dry-run] [-once]

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"k8s.io/kubernetes/pkg/util/sets"

	"github.com/golang/glog"
	"github.com/spf13/cobra"
)

var (
	_ = fmt.Print
)

// RefreshWhitelist updates the whitelist, re-getting the list of committers.
func (config *SubmitQueueConfig) RefreshWhitelist() sets.String {
	if config.additionalUserWhitelist == nil {
		users, err := loadWhitelist(config.Whitelist)
		if err != nil {
			glog.Fatalf("error loading user whitelist: %v", err)
		}
		config.additionalUserWhitelist = &users
	}

	if config.committerList == nil {
		committerList, err := loadWhitelist(config.Committers)
		if err != nil {
			glog.Fatalf("error loading committers whitelist: %v", err)
		}
		config.committerList = &committerList
	}

	allUsers := sets.String{}

	// We must use the values on disk in case it has users which don't have
	// explicit "pull" permission in the API
	allUsers = allUsers.Union(*config.additionalUserWhitelist)

	if pushUsers, pullUsers, err := config.UsersWithAccess(); err != nil {
		glog.Info("Falling back to static committers list.")
		allUsers = allUsers.Union(*config.committerList)
	} else {
		allUsers = allUsers.Union(pushUsers)
		allUsers = allUsers.Union(pullUsers)
	}
	config.userWhitelist = &allUsers
	return allUsers
}

func loadWhitelist(file string) (sets.String, error) {
	result := sets.String{}
	if len(file) == 0 {
		return result, nil
	}
	fp, err := os.Open(file)
	if err != nil {
		return result, err
	}
	defer fp.Close()
	scanner := bufio.NewScanner(fp)
	for scanner.Scan() {
		current := scanner.Text()
		if !strings.HasPrefix(current, "#") {
			result.Insert(current)
		}
	}
	return result, scanner.Err()
}

func writeWhitelist(fileName, header string, users sets.String) error {
	items := append([]string{header}, users.List()...)
	items = append(items, "")
	return ioutil.WriteFile(fileName, []byte(strings.Join(items, "\n")), 0640)
}

func intersection(s1 sets.String, s2 sets.String) sets.String {
	out := sets.String{}
	for a := range s1 {
		if s2.Has(a) {
			out.Insert(a)
		}
	}
	return out
}

func (config *SubmitQueueConfig) doGenCommitters() error {
	pushUsers, pullUsers, err := config.UsersWithAccess()
	if err != nil {
		glog.Fatalf("Unable to read committers from github: %v", err)
	}
	if err = writeWhitelist(config.Committers, "# auto-generated by "+os.Args[0]+" gen-committers; manual additions should go in the whitelist", pushUsers); err != nil {
		glog.Fatalf("Unable to write committers: %v", err)
	}
	glog.Info("Successfully updated committers file.")

	existingWhitelist, err := loadWhitelist(config.Whitelist)
	if err != nil {
		glog.Fatalf("error loading whitelist; it will not be updated: %v", err)
	}

	neededInWhitelist := existingWhitelist.Difference(pushUsers)
	neededInWhitelist = neededInWhitelist.Union(pullUsers)
	if err = writeWhitelist(config.Whitelist, "# auto-generated by "+os.Args[0]+" gen-committers; manual additions may be added by hand", neededInWhitelist); err != nil {
		glog.Fatalf("Unable to write additional user whitelist: %v", err)
	}
	glog.Info("Successfully update whitelist file.")
	return nil
}

func addWhitelistCommand(root *cobra.Command, config *SubmitQueueConfig) {
	genCommitters := &cobra.Command{
		Use:   "gencommiters",
		Short: "Generate the list of people with commit access",
		RunE: func(_ *cobra.Command, _ []string) error {
			if err := config.PreExecute(); err != nil {
				return err
			}
			return config.doGenCommitters()
		},
	}
	root.PersistentFlags().StringVar(&config.Whitelist, "user-whitelist", "./whitelist.txt", "Path to a whitelist file that contains users to auto-merge.  Required.")
	root.PersistentFlags().StringVar(&config.Committers, "committers", "./committers.txt", "File in which the list of authorized committers is stored; only used if this list cannot be gotten at run time.  (Merged with whitelist; separate so that it can be auto-generated)")
	root.Flags().StringVar(&config.WhitelistOverride, "whitelist-override-label", "ok-to-merge", "Github label, if present on a PR it will be merged even if the author isn't in the whitelist")

	root.AddCommand(genCommitters)
}
